I got somewhere. I defined an input language, which is ok, and bult a parser, which makes aan AST tree from generic nodes. Try,

./dancerc.py -p ast ../test/test

Where to go fro here is difficult.

== This guide
This guide is for those who would like to understand Lilypond source code. It is not a line-by-line analysis, or an exhastive API reference.  It is intenfded as a help for navigating the Lilypond codebase.

This guide is not needed if you wish to use Lilypond. But understanding parts of this guide may provide a deeper understanding of how features of Lilypond are constructed, how they behave, and how they connect together.

=== Reading Lilypond code 
=== The two languages
Lilypond is programmed mainly in Guile and C++. People who read code should have little trouble understanding C++ and Guile, line by line. However, here are some hints for trying to understand the structure of the code.

Guile is Scheme-type LISP language, and LISPs tend to be very clean code. However, as there is no namespacing, it is not always clear what is running where and when. If a file is 'executed' or run, it's contents are executed one by one, jumping about and sometimes using macro substitutions. In a file of Guile code, you may want to pay attention to isolated lines, as the file may be executed as a whole.

C++ is often explicit and verbose where other languages would provide convenience structures. Throughout Lilypond C++ files you will see many imports at the top of the file. Bear in mind these represent a wider range of possibilities than other languages.  For example, C++ allows multiple inheritance and free import of interfaces. When looking at Lilypond code, the imported code may not represent a 'this object is/inherits that' connection---it may be building bridges with another system, or encapsulating a small area of functionality. Also, C++ requires explicit definition of how data structures are constructed, so many imports are references to simple structures---for example, the ''Axis' label, very widespread in the music notational code, is a simple enum. 

=== The interface between the two languages
This guide will not cover the how the languages pass information and fuctionality between each other. This is deliberate. The information provides little help in understanding the flow of data and control within Lilypond.

C++ is mainly used in Lilypond to provide efficient data-carrying structures, and low-level collections. Guile code is used to maipulate the data, and interface to the user.

=== A quick guide to the namimg
''gorb' refers to a ''Graphical object'. It is a C++ object wrapped so it can be manipulated by Guile code. Grobs are not even used if Lilypond is constructing for MIDI.

''smob' is a ''Scheme object'. It is used when a Guile object is wrappped or unwrapped for use in Guile code. 

''layout object' is rarely mentioned in the codebase, but we use the idea here. It is the C++ object which backs data-carrying objects used to construct some useful result from Lilypond data.  

''music expression' we do not use this idea much here, but it is the abstract construct, or perhaps the Guile represenstation, constructed from Lilypond's input language. In more general computing terms, the Abstract Syntax Tree returned from the parser.

''event stream' Lilypond reduces source file inputs to an intermediate representation, a list of ''events'. While there is no direct access to this structure, the event stream is used as the input to all processing for Lilypond's two outputs, sheet music and MIDI. For more information, see below, or the paper by Eric Sandberg.  

 
==== An example of the depth of Lilypond code
Here is an example of how Lilypond code, despite the clarity of layout, has become extended. Scattered throughout the code is the command 'get_object'. Let's say you become curious how this is implemented (perhaps those who use LISP aand C++ languages will guess, but this example is for the general code reader). You will find that no 'get_object' method seems to exist on any object. But, deep inside a huge list returned by 'grep', you will discover,

lily/include/lily-guile-macros.hh:#define get_object(x) internal_get_object (ly_symbol2scm (x))

If you search for 'internal_get_object', you will find,

lily/grob-property.cc:Grob::internal_get_object (SCM sym) const

Ah. That command is a interface to Grobs and grob properties. Sometimes it caches, sometimes not. The backing code negociates the differences in types which may be held as properties. The source file also defines a callback 'hook' which can be registered when a property is modified. Overall, the command is for returning Grobs from storage, and an interface to a property system.

This is an indication of Lilypond's maturity. It is also an example how Lilypond's flexible dual-language system can lead to depths in understanding the code.


== Lillypond processing
Not structure---thats well docuented. We'd like to know, but hard to find.

Lillypond is complicated by using Guile, (look for SCM) with callbacks so most properties can be overridden.



=== Control
lilly/main seems to degenerate into multi-processing handling. 

lily/global-context has the big methods on the controlling context.

lily/global-context-scheme contains ly_interpret_music_expression(), which runs iterators. No idea where triggered?


lily.scm seems to handle taking these lists and running them, somehow?

scm/define-music-types joins data to a delivery code, and mentions iterator construction.


=== Triggering and building a model, parsing

We know music is a list,
http://lilypond.org/doc/v2.18/Documentation/extending/internal-music-representation

Probably made from callbacks in Lily-parser.yy (a BISON parser). The callbacks go to scm/ly-syntax-constructors.scm, which makes lists with abstract? contexts built from lists themselves.

The parser is confused by mentioning 'events'. The parser does not make an 'event stream'. The parser is making a stream of Scheme 'SCM' representations of objects. The 'events' mentioned in the parser are a subcategory of a Music Event (as opposed to a Context, PropertyChange etc. in an event stream). The subcategory events are defined in scm/define-music-types.scm (along with an iterator for the data).

Where does the parser make events? This makes a big difference, interleaved events make much easier.

The model is the only straighforward item. Like this, Global->Score->StaffGroups->Staves, all these objects at base are contexts. So we got those as objects. Whre this gets to make event sequences?

=== Iteration
global_contxt contains run_iterator_on_me(), the key method.

music-wrapper-iterator handles both 'music' and child iterators

There are a few specialist iterators, unfold-loop, simultaneous-music-iterator, etc. presumably these are walking music list 'twigs'

music-iterator is interesting. 

- get_static_get_iterator takes 'music' and a property "iterator-ctor", generates a music-wrapper-iterator or whatever, initialises and returns it.

- get_iterator gets an iterator from above, and also builds children



paper-column

=== Outputs

We know that the object list then uses a 'translator' to generate either performance or a writtem scpre.

Lilly parser seems to make 'events'. Events, e.g.

http://lilypond.org/doc/v2.18/Documentation/internals/noteevent

which says the types lead to an engraver.

Where the datatype 'event'? scm/define-event-classes. These are loose, open objects, as you would expect of Guile. scm/define-music-types for the musical sub-classifucations of events.

=== Translation
lily/translation.cc

contains little beyond getting the global context and adding a listener

Whats an acknowledgment?

Performer_group
Score_engraver

Where defined?

=== GROBs
 scm/define-grobs.

=== Penning

=== Engraving and GROBs
lists of engravers,
ly/engraver-init

We know engravers sit in stave information.

We know that the 'cc' versions, not labeled engraver, inherit from 'grob.cc'. grobs have relative x/y positions, relative to a parent. These are called, says some information ''layout objects'? Some grobs are groups of other grobs. It seems that a grob can either be in a vertical group or not, and can find that out.

- Guesses
'stencil' seems to be 'how to draw an effect'. As opposed to writing a glyph.
extents are width/height
spanner: "Some objects are horizontally spanned between objects.  For example, slurs, beams, ties, etc."

- Unknown
skyline? Max extend of everything, including children? Kinda ..."A skyline is a sequence of non-overlapping buildings". That did not help.
What exactly the measurements are? Someting, even relative? y can be 'lines', for notes at least?
How to force fixed widths
Where are they anchored

The connection between grobs and engravers is obscure. 

Engravers can be found by the *-engraver in lilly/. Engravers often carry a process_music() or a create-*() function. These seem to grab generality properties like "middleCPosition", so perhaps are generating grobs? They seem to be the interface between contexts and grobs, whereas the '.cc' grob cotains the full properties and methodolgy of the grob. *-engravers do little besides, say, set the staff-position.

 'item.cc' is dull, aside from showing that 'item' inhertors have visible sizes so affect spacing.

Where exact x/y positions are set is obscure. As is where properties like xExtent for width are set? Maybe from font metrics? In 'rest.cc' it seems the position is set by consulting a base grob property 'staff-position'?



What is notable is that the 'staff' context process list (see below), only seems to chuse note types, etc. Whereas the 'score' context process list has  "Timing_translator", "Default_bar_line_engraver" etc.

bars get numbered. 




TODO: Number bars?test for lengths?

line-interface draws lines from 'offsets' to

=== Why dispatch?
With an event stream, why dispatch? Complicated syem, when we could stary eith data in tables?

is engraving dispatch per context? But why, if we have an event list?

Seems to be partly C++, partly so overridong can be in defined places and not one glob.

=== Engraver/grob
lily/engraver.cc

More intersting. Tells us there are,
Item
Spanner
Paper_column

kinds. And that announce grob is signalled ebvery time. But not so interesting (includes a line number?)?

lily/grob.cc
Stubs for get_system() and

Axis_group_interface has a mutual dependence on Align_interface
 
getting vertical alignments



=== Generating sheet music
While Lilypond can be used to generate MIDI code, the main purpose is to produce sheet music. The following is some help to understanding the Lilypond code for sheet music, and how Lilypond reaches final rendering.

=== Grob data organisation
This snippet gives a clue,

http://lilypond.org/doc/v2.18/Documentation/snippets/tweaks-and-overrides#tweaks-and-overrides-displaying-grob-ancestry

Also, Pointer_group_interface, which seems to be a searchable grob array, backs spanner.cc.

NoteHead X,Y: NoteColumn
    X: PaperColumn
       X,Y: System
    Y: VerticalAxisGroup
       X: NonMusicalPaperColumn
          X,Y: System
       Y: VerticalAlignment
          X: NonMusicalPaperColumn
             X,Y: System
          Y: System

This does clarify something. The grob organisation is a tree of grobs, probably all relatively aligned. 

It also tells us something else. How does Lilypond vertically align output? In a music score, this is essential. Musical staves spread across pages, and must be broken for lines. But, in most scores, barlines on staves must be aligned vertically, and so must the notes between staves. It's worth pointing out that text processing layout engines concentrate on flowing text and line-breaking, not vertical alignment between sucessive line elements. To take an example, CSS engines in web browsers are a sophisticated text and graphic layout engine. Yet they have had, for many years, an inability to organise columns. Even sophisticated text layout engines can not align two characters in successive lines of text (they can centre text, a similar operation). Agreed, this is a a feature most people would not need for text.

The answer is, Lilypond allows separation of X and Y layout positioning. This immediately produces a far more complex layout of graphical model building. X and Y have seperate inheritance chains. but it means the   
 
define-context-properties

Where the tree is rooted, I do not know?

scm/define-context-properties includes,
     (rootSystem ,ly:grob? "The System object.")
->scm/lily.scm (loaded in)
which suggests they are built on contexts?


==== System
The key interface seems to be lilly/system.cc. Includes pre_processing, post_processing and all_elements_

"This is the top-level object: Each object in a score"
               " ultimately has a @code{System} object as its X and"
               " Y@tie{}parent."

It does include plenty of gear about pageing, unmentioned elsewhere.


Then,
#bq
For example, the System grob can be both parent (on the Y-side) and grandparent (twice on the X-side) to a VerticalAlignment grob. 
#
http://lilypond.org/doc/v2.18/Documentation/snippets/tweaks-and-overrides#tweaks-and-overrides-displaying-grob-ancestry



==== Understanding layout code
The layout objects are where the complexity lies, and the calculation.

===== The Dim cache structure
Probably the main thing to understand is there is a lot of code unwrapping C++ layout objects and retrieving and validating properties set by users. This centres round the ''dim_cache_' structure. This is initiated per grob, and in full looks like (Axis is a simple enumeration X = 1, Y = 2, NO_AXES = 3),

dim_cache_ = Array(
Axis.X = (offset, parent, Interval(left, right),
Axis.Y = (offset, parent, Interval(left, right),
Axis.NO_AXES = (offset, parent, Interval(left, right)
)

The result seems to gather given data with user overrides?

===== Pure functions
Many functions in the layout objects are labeled ''pure'. 

Lilypond positioning is a complicated process. It is difficult to know the final positioning of objects before line breaking. Yet a rough estimate of position and size is needed so line breaking can be performed. This problem can be extended to a generality---Lilypond object positions often depend on the positions of other objects. These interactions can cascade---if notes appear on ledger lines, their position is calculated in a different way to notes on staff lines. In turn, the heights of leger lines then affect staff line spacing.

Lilypond layout object informally categorise the ongoing process of positioning by creating a set of functions called 'pure' functions. Pure functions are a guess at the size and positioning of Lilypond objects. While the ideas around how pure functions are informal, they are mostly the same. The calculation of a guess should not rely on data that mutates (the data may be pre-set from properties but, for example, should not be a temporary or an accumulating variable). A pure function should always return the same result (be 'idempotent'). And a pure function should not affect data elsewhere (cause side-effects). 

Sometimes the positiong and height can be provided by pure functions only. Note heads are only styled from music properties like duration. They not change size depending on other values. The guess will be the final value.

Pure functions are used early in the positioning process, before line-breaking. pure functions have a formal signature which may include start and end positioning, end position is not needed for single items, and is redundant. Pure functions do not need to be registered, and Lilypond searches to see if a grob can return a pure value.

Pure functions only appear for Y axis calculations, because the X axis is 'free', and the Y axis positioning depends on it. 

This commentary is enough to help you identify a large swathe of funtionality when reading the code. It is probably not enough to help you write a pure function. For that, see the documetation below.

Lillypond ''Contributors' manual contains a full section on ''pure' functions,  
http://lilypond.org/doc/v2.18/Documentation/contributor/understanding-pure-properties


=== in SHORT
Don't know where control goes after scm/lilly. Does it run the functions in scm/music-functions?

Don't know what a music event is as data, besides a type.

Don't know how engravers get attached to contexts

Don't know if final coordinates are controlled by engravers or layout. Or where they are triggerd.

Can't find layout data either

Or how bars are handled---objects or calculated?

Or how columns align across lists


Or final X/Y coordinate holders.

All bad.

See also,
http://lilypond.org/doc/v2.18/Documentation/contributor/overview-of-lilypond-architecture
?
This is good, on the music sreaam, though it fails to explain interlacing?

http://lilypond.org/website/pdf/thesis-erik-sandberg.pdf
?
== What we need
We do need a basic parse, if only for error checking.
...and expansion
We need this general AST to render to a neutral struction to be used for both text and animation rendering.

Would this be a music stream, with notes marked?
e.g.
(time 0: note e’2, lower staff, lower voice)
for dancer
(time 0: move clap dancer 1)

So we need to add time and dancer id, while interlacing.
We need specific renderers for text and animation.

Like Lilypond, we could maybe use having these two different results fro a flexible phase structure, like lillypond's engraver/performance split.

engraver-init.ly:
in declarations-init.ly
in init.ly
in lily/lily-parsr-scheme.cc

Score:

  \consists "Paper_column_engraver"
  \consists "Repeat_acknowledge_engraver"
  \consists "Staff_collecting_engraver"

  \alias "Timing"

  %% An alias for Timing is established by the Timing_translator in
  %% whatever context it is initialized, and the timing variables are
  %% then copied from wherever Timing had been previously established.
  %% The alias at Score level provides a target for initializing
  %% Timing variables in layout definitions before any
  %% Timing_translator has been run.

  % timing translator must come BEFORE bar number engraver
  \consists "Timing_translator"
  \consists "Default_bar_line_engraver"
  \consists "Output_property_engraver"
  \consists "Tweak_engraver"
  \consists "System_start_delimiter_engraver"
  \consists "Mark_engraver"
  \consists "Volta_engraver"
  \consists "Metronome_mark_engraver"
  \consists "Break_align_engraver"
  \consists "Spacing_engraver"
  \consists "Grace_spacing_engraver"
  \consists "Vertical_align_engraver"
  \consists "Stanza_number_align_engraver"
  \consists "Bar_number_engraver"
  \consists "Parenthesis_engraver"
  \consists "Concurrent_hairpin_engraver"
  \consists "Beam_collision_engraver"
  \consists "Footnote_engraver"

  \defaultchild "Staff"

  \accepts "FretBoards"
  \accepts "Staff"
  \accepts "RhythmicStaff"
  \accepts "TabStaff"
  \accepts "VaticanaStaff"
  \accepts "GregorianTranscriptionStaff"
  \accepts "MensuralStaff"
  \accepts "PetrucciStaff"
  \accepts "StaffGroup"
  \accepts "DrumStaff"
  \accepts "KievanStaff"
  \accepts "Lyrics"
  \accepts "ChordNames"
  \accepts "GrandStaff"
  \accepts "ChoirStaff"
  \accepts "PianoStaff"
  \accepts "Devnull"
  \accepts "NoteNames"
  \accepts "FiguredBass"

  noteToFretFunction = #determine-frets
  predefinedDiagramTable = ##f
  soloText = #"Solo"
  soloIIText = #"Solo II"
  aDueText = #"a2"
  printPartCombineTexts = ##t
  partCombineTextsOnNote = ##t
  systemStartDelimiter =#'SystemStartBar

  drumStyleTable = #drums-style

  melismaBusyProperties = #default-melisma-properties
  tieWaitForNote = ##f
  clefGlyph = #"clefs.G"
  clefPosition = #-2
  middleCClefPosition = #-6
  middleCPosition = #-6
  firstClef = ##t

  crescendoSpanner = #'hairpin
  decrescendoSpanner = #'hairpin

  defaultBarType = #"|"
  doubleRepeatType = #":..:"
  startRepeatType = #".|:"
  endRepeatType = #":|."
  barNumberVisibility = #first-bar-number-invisible-and-no-parenthesized-bar-numbers
  barNumberFormatter = #robust-bar-number-function
  clefTranspositionFormatter = #clef-transposition-markup
  cueClefTranspositionFormatter = #clef-transposition-markup
  automaticBars = ##t

  explicitClefVisibility = #all-visible
  explicitCueClefVisibility = #end-of-line-invisible
  explicitKeySignatureVisibility = #all-visible
  implicitTimeSignatureVisibility = #end-of-line-invisible

  repeatCountVisibility = #all-repeat-counts-visible

%% Other Timing variables are derived and set by the Timing_translator
%% at initialization time by calling the functions in
%% scm/time-signature-settings.scm

  timeSignatureSettings = #default-time-signature-settings
  timeSignatureFraction = 4/4

  beamHalfMeasure = ##t

  autoBeaming = ##t
  autoBeamCheck = #default-auto-beam-check

  scriptDefinitions = #default-script-alist

  pedalSustainStrings = #'("Ped." "*Ped." "*")
  pedalSustainStyle = #'text
  pedalUnaCordaStrings = #'("una corda" "" "tre corde")
  pedalUnaCordaStyle = #'text

%% These are in ordinary italic font, including the *,
%% but they are unlikely to be used,
%% as the default pedal-style for SostenutoPedal is 'mixed':
%% i.e.  Sost. Ped_____________________
  pedalSostenutoStrings = #'("Sost. Ped." "*Sost. Ped." "*")
  pedalSostenutoStyle = #'mixed

  harmonicAccidentals = ##t
  fingeringOrientations = #'(up down)
  stringNumberOrientations = #'(up down)
  strokeFingerOrientations = #'(right)

  lyricMelismaAlignment = #LEFT
  markFormatter = #format-mark-letters
  rehearsalMark = #1
  subdivideBeams = ##f
  extraNatural = ##t
  autoAccidentals = #`(Staff ,(make-accidental-rule 'same-octave 0))
  autoCautionaries = #'()

  printKeyCancellation = ##t
  keyAlterationOrder = #`(
    (6 . ,FLAT) (2  . ,FLAT) (5 . ,FLAT ) (1  . ,FLAT) (4  . ,FLAT) (0  . ,FLAT) (3  . ,FLAT)
    (3 . ,SHARP) (0 . ,SHARP) (4 . ,SHARP) (1 . ,SHARP) (5 . ,SHARP) (2 . ,SHARP) (6 . ,SHARP)
    (6 . ,DOUBLE-FLAT) (2 . ,DOUBLE-FLAT) (5 . ,DOUBLE-FLAT ) (1 . ,DOUBLE-FLAT) (4 . ,DOUBLE-FLAT) (0 . ,DOUBLE-FLAT) (3 . ,DOUBLE-FLAT)
    (3  . ,DOUBLE-SHARP) (0 . ,DOUBLE-SHARP) (4 . ,DOUBLE-SHARP) (1 . ,DOUBLE-SHARP) (5 . ,DOUBLE-SHARP) (2 . ,DOUBLE-SHARP) (6 . ,DOUBLE-SHARP)
  )

  barCheckSynchronize = ##f

%% chord names:
  chordNameFunction = #ignatzek-chord-names
  minorChordModifier = #(make-simple-markup "m")
  additionalPitchPrefix = #"" % was "add"
  majorSevenSymbol = #whiteTriangleMarkup
  chordNameLowercaseMinor = ##f
  chordNameSeparator = #(make-hspace-markup 0.5)
  slashChordSeparator = #(make-simple-markup "/")
  chordNameExceptions = #ignatzekExceptions
  chordNoteNamer = #'()
  chordRootNamer = #note-name->markup
  chordPrefixSpacer = #0
  chordNameExceptionsFull = #fullJazzExceptions
  chordNameExceptionsPartial = #partialJazzExceptions
  noChordSymbol = #(make-simple-markup "N.C.")

  bassStaffProperties = #'((assign clefGlyph "clefs.F")
  (assign clefPosition 2)
  (assign middleCPosition 6)
  (assign middleCClefPosition 6))
%% tablature:
  stringOneTopmost = ##t
  highStringOne = ##t

%% One may change the string tunings as follows :
%% The length of the list must be equal to the number of strings
  stringTunings = #guitar-tuning
  tablatureFormat = #fret-number-tablature-format
  tabStaffLineLayoutFunction = #tablature-position-on-lines

%%
  figuredBassFormatter = #format-bass-figure
  metronomeMarkFormatter = #format-metronome-markup

  %% See also make-voice-props-set
  graceSettings = #score-grace-settings

  keepAliveInterfaces = #'(
    bass-figure-interface
    chord-name-interface
    cluster-beacon-interface
    fret-diagram-interface
    lyric-syllable-interface
    note-head-interface
    tab-note-head-interface
    lyric-interface
    percent-repeat-item-interface
    percent-repeat-interface

    ;; need this, as stanza numbers are items, and appear only once.
    stanza-number-interface
  )
  % \quoteDuring is supposed to quote everything, cueDuring only the essentials
  quotedEventTypes = #'(StreamEvent)
  quotedCueEventTypes = #'(
    note-event
    rest-event
    tie-event
    beam-event
    tuplet-span-event)
  instrumentTransposition = #(ly:make-pitch 0 0 0)

  topLevelAlignment = ##t

  timing = ##t

Staff:

  \consists "Font_size_engraver"

  \consists "Pitched_trill_engraver"
  \consists "Output_property_engraver"
  \consists "Arpeggio_engraver"
  \consists "Multi_measure_rest_engraver"
  \consists "Text_spanner_engraver"
  \consists "Trill_spanner_engraver"
  \consists "Grob_pq_engraver"
  \consists "Forbid_line_break_engraver"
  \consists "Laissez_vibrer_engraver"
  \consists "Repeat_tie_engraver"
  \consists "Note_head_line_engraver"
  \consists "Glissando_engraver"
  \consists "Ligature_bracket_engraver"
  \consists "Breathing_sign_engraver"
  \consists "Note_heads_engraver"
  \consists "Dots_engraver"
  \consists "Rest_engraver"

  %% switch on to make stem directions interpolate for the
  %% center line.
  %  \consists "Melody_engraver"

  \consists "Stem_engraver"
  \consists "Beam_engraver"
  \consists "Grace_beam_engraver"
  \consists "Auto_beam_engraver"
  \consists "Grace_auto_beam_engraver"

  %% must come before Script_column_engraver.
  \consists "New_fingering_engraver"

  \consists "Chord_tremolo_engraver"
  \consists "Double_percent_repeat_engraver"
  \consists "Percent_repeat_engraver"
  \consists "Slash_repeat_engraver"
  \consists "Part_combine_engraver"

  \consists "Text_engraver"
  \consists "Dynamic_engraver"
  \consists "Dynamic_align_engraver"
  \consists "Fingering_engraver"
  \consists "Bend_engraver"

  \consists "Script_engraver"
  \consists "Script_column_engraver"
  \consists "Rhythmic_column_engraver"
  \consists "Note_spacing_engraver"
  \consists "Spanner_break_forbid_engraver"
  \consists "Phrasing_slur_engraver"
  \consists "Cluster_spanner_engraver"
  \consists "Slur_engraver"
  \consists "Tie_engraver"
  \consists "Tuplet_engraver"
  \consists "Grace_engraver"
  \consists "Instrument_switch_engraver"


voice: 

  \consists "Font_size_engraver"

  \consists "Pitched_trill_engraver"
  \consists "Output_property_engraver"
  \consists "Arpeggio_engraver"
  \consists "Multi_measure_rest_engraver"
  \consists "Text_spanner_engraver"
  \consists "Trill_spanner_engraver"
  \consists "Grob_pq_engraver"
  \consists "Forbid_line_break_engraver"
  \consists "Laissez_vibrer_engraver"
  \consists "Repeat_tie_engraver"
  \consists "Note_head_line_engraver"
  \consists "Glissando_engraver"
  \consists "Ligature_bracket_engraver"
  \consists "Breathing_sign_engraver"
  \consists "Note_heads_engraver"
  \consists "Dots_engraver"
  \consists "Rest_engraver"

  %% switch on to make stem directions interpolate for the
  %% center line.
  %  \consists "Melody_engraver"

  \consists "Stem_engraver"
  \consists "Beam_engraver"
  \consists "Grace_beam_engraver"
  \consists "Auto_beam_engraver"
  \consists "Grace_auto_beam_engraver"

  %% must come before Script_column_engraver.
  \consists "New_fingering_engraver"

  \consists "Chord_tremolo_engraver"
  \consists "Double_percent_repeat_engraver"
  \consists "Percent_repeat_engraver"
  \consists "Slash_repeat_engraver"
  \consists "Part_combine_engraver"

  \consists "Text_engraver"
  \consists "Dynamic_engraver"
  \consists "Dynamic_align_engraver"
  \consists "Fingering_engraver"
  \consists "Bend_engraver"

  \consists "Script_engraver"
  \consists "Script_column_engraver"
  \consists "Rhythmic_column_engraver"
  \consists "Note_spacing_engraver"
  \consists "Spanner_break_forbid_engraver"
  \consists "Phrasing_slur_engraver"
  \consists "Cluster_spanner_engraver"
  \consists "Slur_engraver"
  \consists "Tie_engraver"
  \consists "Tuplet_engraver"
  \consists "Grace_engraver"
  \consists "Instrument_switch_engraver"


 
== PDF rendering
TODO: Main one---decide how to generate x/y coordinates fron the tree parse.
And also, how to coordinate between dancers?

scm/music-functions has tree recursers? These pesumably do...
TODO: compiler phases to generate specifics from the generic parse. In particular, instruction functions must be run to generate event, e.g. non visual repeats expanded, visual repeats with barline instructions, etc.
 


